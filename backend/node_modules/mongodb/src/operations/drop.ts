import type { Document } from '../bson';
import type { Db } from '../db';
import { MONGODB_ERROR_CODES, MongoServerError } from '../error';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import type { Callback } from '../utils';
<<<<<<< HEAD
import { CommandOperation, CommandOperationOptions } from './command';
=======
import { CommandCallbackOperation, type CommandOperationOptions } from './command';
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
import { Aspect, defineAspects } from './operation';

/** @public */
export interface DropCollectionOptions extends CommandOperationOptions {
  /** @experimental */
  encryptedFields?: Document;
}

/** @internal */
<<<<<<< HEAD
export class DropCollectionOperation extends CommandOperation<boolean> {
=======
export class DropCollectionOperation extends CommandCallbackOperation<boolean> {
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
  override options: DropCollectionOptions;
  db: Db;
  name: string;

  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {
    super(db, options);
    this.db = db;
    this.options = options;
    this.name = name;
  }

<<<<<<< HEAD
  override execute(
=======
  override executeCallback(
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
    server: Server,
    session: ClientSession | undefined,
    callback: Callback<boolean>
  ): void {
    (async () => {
      const db = this.db;
      const options = this.options;
      const name = this.name;

<<<<<<< HEAD
      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;
=======
      const encryptedFieldsMap = db.client.options.autoEncryption?.encryptedFieldsMap;
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
      let encryptedFields: Document | undefined =
        options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];

      if (!encryptedFields && encryptedFieldsMap) {
        // If the MongoClient was configured with an encryptedFieldsMap,
        // and no encryptedFields config was available in it or explicitly
        // passed as an argument, the spec tells us to look one up using
        // listCollections().
        const listCollectionsResult = await db
          .listCollections({ name }, { nameOnly: false })
          .toArray();
        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
      }

      if (encryptedFields) {
        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
<<<<<<< HEAD
        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;
        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;

        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {
=======
        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;

        for (const collectionName of [escCollection, ecocCollection]) {
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.
          const dropOp = new DropCollectionOperation(db, collectionName);
          try {
            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);
          } catch (err) {
            if (
              !(err instanceof MongoServerError) ||
              err.code !== MONGODB_ERROR_CODES.NamespaceNotFound
            ) {
              throw err;
            }
          }
        }
      }

      return this.executeWithoutEncryptedFieldsCheck(server, session);
    })().then(
      result => callback(undefined, result),
      err => callback(err)
    );
  }

  private executeWithoutEncryptedFieldsCheck(
    server: Server,
    session: ClientSession | undefined
  ): Promise<boolean> {
    return new Promise<boolean>((resolve, reject) => {
<<<<<<< HEAD
      super.executeCommand(server, session, { drop: this.name }, (err, result) => {
=======
      super.executeCommandCallback(server, session, { drop: this.name }, (err, result) => {
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
        if (err) return reject(err);
        resolve(!!result.ok);
      });
    });
  }
}

/** @public */
export type DropDatabaseOptions = CommandOperationOptions;

/** @internal */
<<<<<<< HEAD
export class DropDatabaseOperation extends CommandOperation<boolean> {
=======
export class DropDatabaseOperation extends CommandCallbackOperation<boolean> {
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
  override options: DropDatabaseOptions;

  constructor(db: Db, options: DropDatabaseOptions) {
    super(db, options);
    this.options = options;
  }
<<<<<<< HEAD
  override execute(
=======
  override executeCallback(
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
    server: Server,
    session: ClientSession | undefined,
    callback: Callback<boolean>
  ): void {
<<<<<<< HEAD
    super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {
=======
    super.executeCommandCallback(server, session, { dropDatabase: 1 }, (err, result) => {
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
      if (err) return callback(err);
      if (result.ok) return callback(undefined, true);
      callback(undefined, false);
    });
  }
}

defineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);
defineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);
