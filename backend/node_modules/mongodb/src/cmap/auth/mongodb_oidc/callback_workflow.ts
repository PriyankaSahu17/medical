import { Binary, BSON, type Document } from 'bson';

<<<<<<< HEAD
import { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../../error';
import { ns } from '../../../utils';
import type { Connection } from '../../connection';
import type { MongoCredentials } from '../mongo_credentials';
import type { OIDCMechanismServerStep1, OIDCRequestTokenResult } from '../mongodb_oidc';
import { AuthMechanism } from '../providers';
import { TokenEntryCache } from './token_entry_cache';
import type { Workflow } from './workflow';

/* 5 minutes in milliseconds */
const TIMEOUT_MS = 300000;
=======
import { MONGODB_ERROR_CODES, MongoError, MongoMissingCredentialsError } from '../../../error';
import { ns } from '../../../utils';
import type { Connection } from '../../connection';
import type { MongoCredentials } from '../mongo_credentials';
import type {
  IdPServerInfo,
  IdPServerResponse,
  OIDCCallbackContext,
  OIDCRefreshFunction,
  OIDCRequestFunction,
  Workflow
} from '../mongodb_oidc';
import { AuthMechanism } from '../providers';
import { CallbackLockCache } from './callback_lock_cache';
import { TokenEntryCache } from './token_entry_cache';

/** The current version of OIDC implementation. */
const OIDC_VERSION = 0;

/** 5 minutes in seconds */
const TIMEOUT_S = 300;

/** Properties allowed on results of callbacks. */
const RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];

/** Error message when the callback result is invalid. */
const CALLBACK_RESULT_ERROR =
  'User provided OIDC callbacks must return a valid object with an accessToken.';
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf

/**
 * OIDC implementation of a callback based workflow.
 * @internal
 */
export class CallbackWorkflow implements Workflow {
  cache: TokenEntryCache;
<<<<<<< HEAD
=======
  callbackCache: CallbackLockCache;
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf

  /**
   * Instantiate the workflow
   */
  constructor() {
    this.cache = new TokenEntryCache();
<<<<<<< HEAD
  }

  /**
   * Get the document to add for speculative authentication. Is empty when
   * callbacks are in play.
   */
  speculativeAuth(): Promise<Document> {
    return Promise.resolve({});
  }

  /**
   * Execute the workflow.
   *
   * Steps:
   * - If an entry is in the cache
   *   - If it is not expired
   *     - Skip step one and use the entry to execute step two.
   *   - If it is expired
   *     - If the refresh callback exists
   *       - remove expired entry from cache
   *       - call the refresh callback.
   *       - put the new entry in the cache.
   *       - execute step two.
   *     - If the refresh callback does not exist.
   *       - remove expired entry from cache
   *       - call the request callback.
   *       - put the new entry in the cache.
   *       - execute step two.
   * - If no entry is in the cache.
   *   - execute step one.
   *   - call the refresh callback.
   *   - put the new entry in the cache.
   *   - execute step two.
=======
    this.callbackCache = new CallbackLockCache();
  }

  /**
   * Get the document to add for speculative authentication. This also needs
   * to add a db field from the credentials source.
   */
  async speculativeAuth(credentials: MongoCredentials): Promise<Document> {
    const document = startCommandDocument(credentials);
    document.db = credentials.source;
    return { speculativeAuthenticate: document };
  }

  /**
   * Execute the OIDC callback workflow.
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
   */
  async execute(
    connection: Connection,
    credentials: MongoCredentials,
<<<<<<< HEAD
    reauthenticate = false
  ): Promise<Document> {
    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;

    const entry = this.cache.getEntry(
      connection.address,
      credentials.username,
      request || null,
      refresh || null
    );
    if (entry) {
      // Check if the entry is not expired and if we are reauthenticating.
      if (!reauthenticate && entry.isValid()) {
        // Skip step one and execute the step two saslContinue.
        try {
          const result = await finishAuth(entry.tokenResult, undefined, connection, credentials);
          return result;
        } catch (error) {
          // If authentication errors when using a cached token we remove it from
          // the cache.
          this.cache.deleteEntry(
            connection.address,
            credentials.username || '',
            request || null,
            refresh || null
          );
          throw error;
        }
      } else {
        // Remove the expired entry from the cache.
        this.cache.deleteEntry(
          connection.address,
          credentials.username || '',
          request || null,
          refresh || null
        );
        // Execute a refresh of the token and finish auth.
        return this.refreshAndFinish(
          connection,
          credentials,
          entry.serverResult,
          entry.tokenResult
        );
      }
    } else {
      // No entry means to start with the step one saslStart.
      const result = await connection.commandAsync(
=======
    reauthenticating: boolean,
    response?: Document
  ): Promise<Document> {
    // Get the callbacks with locks from the callback lock cache.
    const { requestCallback, refreshCallback, callbackHash } = this.callbackCache.getEntry(
      connection,
      credentials
    );
    // Look for an existing entry in the cache.
    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
    let result;
    if (entry) {
      // Reauthentication cannot use a token from the cache since the server has
      // stated it is invalid by the request for reauthentication.
      if (entry.isValid() && !reauthenticating) {
        // Presence of a valid cache entry means we can skip to the finishing step.
        result = await this.finishAuthentication(
          connection,
          credentials,
          entry.tokenResult,
          response?.speculativeAuthenticate?.conversationId
        );
      } else {
        // Presence of an expired cache entry means we must fetch a new one and
        // then execute the final step.
        const tokenResult = await this.fetchAccessToken(
          connection,
          credentials,
          entry.serverInfo,
          reauthenticating,
          callbackHash,
          requestCallback,
          refreshCallback
        );
        try {
          result = await this.finishAuthentication(
            connection,
            credentials,
            tokenResult,
            reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId
          );
        } catch (error) {
          // If we are reauthenticating and this errors with reauthentication
          // required, we need to do the entire process over again and clear
          // the cache entry.
          if (
            reauthenticating &&
            error instanceof MongoError &&
            error.code === MONGODB_ERROR_CODES.Reauthenticate
          ) {
            this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
            result = await this.execute(connection, credentials, reauthenticating);
          } else {
            throw error;
          }
        }
      }
    } else {
      // No entry in the cache requires us to do all authentication steps
      // from start to finish, including getting a fresh token for the cache.
      const startDocument = await this.startAuthentication(
        connection,
        credentials,
        reauthenticating,
        response
      );
      const conversationId = startDocument.conversationId;
      const serverResult = BSON.deserialize(startDocument.payload.buffer) as IdPServerInfo;
      const tokenResult = await this.fetchAccessToken(
        connection,
        credentials,
        serverResult,
        reauthenticating,
        callbackHash,
        requestCallback,
        refreshCallback
      );
      result = await this.finishAuthentication(
        connection,
        credentials,
        tokenResult,
        conversationId
      );
    }
    return result;
  }

  /**
   * Starts the callback authentication process. If there is a speculative
   * authentication document from the initial handshake, then we will use that
   * value to get the issuer, otherwise we will send the saslStart command.
   */
  private async startAuthentication(
    connection: Connection,
    credentials: MongoCredentials,
    reauthenticating: boolean,
    response?: Document
  ): Promise<Document> {
    let result;
    if (!reauthenticating && response?.speculativeAuthenticate) {
      result = response.speculativeAuthenticate;
    } else {
      result = await connection.commandAsync(
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
        ns(credentials.source),
        startCommandDocument(credentials),
        undefined
      );
<<<<<<< HEAD
      const stepOne = BSON.deserialize(result.payload.buffer) as OIDCMechanismServerStep1;
      // Call the request callback and finish auth.
      return this.requestAndFinish(connection, credentials, stepOne, result.conversationId);
    }
  }

  /**
   * Execute the refresh callback if it exists, otherwise the request callback, then
   * finish the authentication.
   */
  private async refreshAndFinish(
    connection: Connection,
    credentials: MongoCredentials,
    stepOneResult: OIDCMechanismServerStep1,
    tokenResult: OIDCRequestTokenResult,
    conversationId?: number
  ): Promise<Document> {
    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;
    // If a refresh callback exists, use it. Otherwise use the request callback.
    if (refresh) {
      const result: OIDCRequestTokenResult = await refresh(
        credentials.username,
        stepOneResult,
        tokenResult,
        TIMEOUT_MS
      );
      // Validate the result.
      if (!result || !result.accessToken) {
        throw new MongoMissingCredentialsError(
          'REFRESH_TOKEN_CALLBACK must return a valid object with an accessToken'
        );
      }
      // Cache a new entry and continue with the saslContinue.
      this.cache.addEntry(
        connection.address,
        credentials.username || '',
        request || null,
        refresh,
        result,
        stepOneResult
      );
      return finishAuth(result, conversationId, connection, credentials);
    } else {
      // Fallback to using the request callback.
      return this.requestAndFinish(connection, credentials, stepOneResult, conversationId);
    }
  }

  /**
   * Execute the request callback and finish authentication.
   */
  private async requestAndFinish(
    connection: Connection,
    credentials: MongoCredentials,
    stepOneResult: OIDCMechanismServerStep1,
    conversationId?: number
  ): Promise<Document> {
    // Call the request callback.
    const request = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
    const refresh = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;
    // Always clear expired entries from the cache on each finish as cleanup.
    this.cache.deleteExpiredEntries();
    if (!request) {
      // Request callback must be present.
      throw new MongoInvalidArgumentError(
        'Auth mechanism property REQUEST_TOKEN_CALLBACK is required.'
      );
    }
    const tokenResult = await request(credentials.username, stepOneResult, TIMEOUT_MS);
    // Validate the result.
    if (!tokenResult || !tokenResult.accessToken) {
      throw new MongoMissingCredentialsError(
        'REQUEST_TOKEN_CALLBACK must return a valid object with an accessToken'
      );
    }
    // Cache a new entry and continue with the saslContinue.
    this.cache.addEntry(
      connection.address,
      credentials.username || '',
      request,
      refresh || null,
      tokenResult,
      stepOneResult
    );
    return finishAuth(tokenResult, conversationId, connection, credentials);
=======
    }
    return result;
  }

  /**
   * Finishes the callback authentication process.
   */
  private async finishAuthentication(
    connection: Connection,
    credentials: MongoCredentials,
    tokenResult: IdPServerResponse,
    conversationId?: number
  ): Promise<Document> {
    const result = await connection.commandAsync(
      ns(credentials.source),
      finishCommandDocument(tokenResult.accessToken, conversationId),
      undefined
    );
    return result;
  }

  /**
   * Fetches an access token using either the request or refresh callbacks and
   * puts it in the cache.
   */
  private async fetchAccessToken(
    connection: Connection,
    credentials: MongoCredentials,
    serverInfo: IdPServerInfo,
    reauthenticating: boolean,
    callbackHash: string,
    requestCallback: OIDCRequestFunction,
    refreshCallback?: OIDCRefreshFunction
  ): Promise<IdPServerResponse> {
    // Get the token from the cache.
    const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
    let result;
    const context: OIDCCallbackContext = { timeoutSeconds: TIMEOUT_S, version: OIDC_VERSION };
    // Check if there's a token in the cache.
    if (entry) {
      // If the cache entry is valid, return the token result.
      if (entry.isValid() && !reauthenticating) {
        return entry.tokenResult;
      }
      // If the cache entry is not valid, remove it from the cache and first attempt
      // to use the refresh callback to get a new token. If no refresh callback
      // exists, then fallback to the request callback.
      if (refreshCallback) {
        context.refreshToken = entry.tokenResult.refreshToken;
        result = await refreshCallback(serverInfo, context);
      } else {
        result = await requestCallback(serverInfo, context);
      }
    } else {
      // With no token in the cache we use the request callback.
      result = await requestCallback(serverInfo, context);
    }
    // Validate that the result returned by the callback is acceptable. If it is not
    // we must clear the token result from the cache.
    if (isCallbackResultInvalid(result)) {
      this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
      throw new MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
    }
    // Cleanup the cache.
    this.cache.deleteExpiredEntries();
    // Put the new entry into the cache.
    this.cache.addEntry(
      connection.address,
      credentials.username || '',
      callbackHash,
      result,
      serverInfo
    );
    return result;
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
  }
}

/**
<<<<<<< HEAD
 * Cache the result of the user supplied callback and execute the
 * step two saslContinue.
 */
async function finishAuth(
  result: OIDCRequestTokenResult,
  conversationId: number | undefined,
  connection: Connection,
  credentials: MongoCredentials
): Promise<Document> {
  // Execute the step two saslContinue.
  return connection.commandAsync(
    ns(credentials.source),
    continueCommandDocument(result.accessToken, conversationId),
    undefined
  );
=======
 * Generate the finishing command document for authentication. Will be a
 * saslStart or saslContinue depending on the presence of a conversation id.
 */
function finishCommandDocument(token: string, conversationId?: number): Document {
  if (conversationId != null && typeof conversationId === 'number') {
    return {
      saslContinue: 1,
      conversationId: conversationId,
      payload: new Binary(BSON.serialize({ jwt: token }))
    };
  }
  // saslContinue requires a conversationId in the command to be valid so in this
  // case the server allows "step two" to actually be a saslStart with the token
  // as the jwt since the use of the cached value has no correlating conversating
  // on the particular connection.
  return {
    saslStart: 1,
    mechanism: AuthMechanism.MONGODB_OIDC,
    payload: new Binary(BSON.serialize({ jwt: token }))
  };
}

/**
 * Determines if a result returned from a request or refresh callback
 * function is invalid. This means the result is nullish, doesn't contain
 * the accessToken required field, and does not contain extra fields.
 */
function isCallbackResultInvalid(tokenResult: unknown): boolean {
  if (tokenResult == null || typeof tokenResult !== 'object') return true;
  if (!('accessToken' in tokenResult)) return true;
  return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
}

/**
 * Generate the saslStart command document.
 */
function startCommandDocument(credentials: MongoCredentials): Document {
  const payload: Document = {};
  if (credentials.username) {
    payload.n = credentials.username;
  }
  return {
    saslStart: 1,
    autoAuthorize: 1,
    mechanism: AuthMechanism.MONGODB_OIDC,
    payload: new Binary(BSON.serialize(payload))
  };
}
<<<<<<< HEAD

/**
 * Generate the saslContinue command document.
 */
function continueCommandDocument(token: string, conversationId?: number): Document {
  if (conversationId) {
    return {
      saslContinue: 1,
      conversationId: conversationId,
      payload: new Binary(BSON.serialize({ jwt: token }))
    };
  }
  // saslContinue requires a conversationId in the command to be valid so in this
  // case the server allows "step two" to actually be a saslStart with the token
  // as the jwt since the use of the cached value has no correlating conversating
  // on the particular connection.
  return {
    saslStart: 1,
    mechanism: AuthMechanism.MONGODB_OIDC,
    payload: new Binary(BSON.serialize({ jwt: token }))
  };
}
=======
>>>>>>> fbc8dfd1dc1e8142d05458c7d646053f0b1a6dbf
